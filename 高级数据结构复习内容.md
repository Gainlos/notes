# 高级数据结构复习内容

## 跳表

### 函数操作

1. ==插入==的时候每一个结点都有一个地址数组。存储每一层结点之后的内容。要插入的实话，就要从最上面一层遍历到最下面一层。然后找到位置，插入结点，同时根据update数组对每一层进行更新。
1. 搜索 类似的操作
1. 删除 和插入差不多，但是找到结点之后，将这个结点前后的内容穿起来，记得向上跳

### 特点

1. 有点时间换空间的味道。每个结点都会有一个forwards数组。然后数组里储存这个结点后面的每一层的结点。
2. 复杂度分析查找的话，应该是对数级别的复杂度。
3. PicGo+Typora
4. ![](www.baidu.com)



### 作业分析

1. 跳表搜索路径的长度
2. 

![image-20220906084310335](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20220906084310335.png)

## 布隆过滤器

### 简介特点

是一种快速查找元素是否存在于集合之中的方法。只能判断是否有，不能判断在哪里。

















### 









## AVL树

### 概念介绍

1. 左旋 右旋
2. 双旋
   1. 连续一个方向的旋转
   2. 先向一个方向转，再向另一个方向转
3. 方便查询，但是插入的复杂度会更高，以为需要调整，来保证左右子树的高度差不超过1

### 具体实现

1. 定义一个平衡因子

   

**最小失衡子树**：在新插入的结点向上查找，以第一个平衡因子的**绝对值**超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。

### 调整方式 

1. 先找到最下平衡子树
2. 然后判断是需要双旋还是单旋



### 作业分析

1. 顺序和逆序的插入是类似的（有点对称的感觉）
2. 随机插入要慢于顺序和逆序【理论而言，随机插入的旋转次数应该是少的】（实际情况，顺序插入的缓存命中率更高，所以会更快一点点）







## Splay树

### 特点介绍

1. 利用了局部性原理
2. 结点一旦被访问，就被调整到树根。

### 具体实现

1. 利用伸展的方式，将访问的结点，伸展到根节点。但是不是利用单层伸展，而是双层伸展。【所谓的双层伸展，并不是一层一层的展开到两层 ，因为这样和单层伸展两次没有什么不同，而是从向上的第二层为基点开始伸展，每次旋转两次为单位】
1. 伸展的时候zig-zig与一般的伸展不同，但是zig-zag的时候，旋转方式与单层的旋转方式是一样的





### 作业分析

1. 不同比率查找集的的查找效率
2. Splay在数据集较少的时候，会好一点。



## B树

### 基本介绍

1. 我们假设我们的数据量达到了亿级别，主存当中根本存储不下，我们只能以块的形式从磁盘读取数据，与主存的访问时间相比，磁盘的 I/O 操作相当耗时，而提出 B-树的主要目的就是减少磁盘的 I/O 操作。
2. 特点
   1. m阶b树【成为m路平衡搜索树，更为恰当，有m路分支】
      1. 叶子结点都在同一层上
      2. 每个内部结点都有不超过m-1个关键码，同时关键码也不能太少，除了根节点以外都至少关键码数量n+1≤[m/2]【向上取整】个结点，比如3阶b树至少要有2个关键码，所以又称作(2,3)树

### 基本操作

1. 插入

2. 查找

3. 删除
#### 上溢分裂 
   可能会出现==上溢或者分裂==的情况。【要注意上溢或分裂的具体情况】

   1. 找到中间的那个结点（如果是奇数个，则正好是中间的那个结点，偶数个，则是相对靠后的那一个位）。然后将该点与父节点合并

   2. 之后剩余的左右部分的关键码，化为该关键码左右两侧的子树

   3. 若父节点饱和，则继续采取相应的措施，进行提升。一直到根节点

      【课本p221例子】

#### 下溢与合并

​	不做要求





## 红黑树

### 基本概念

1. 适度平衡 任意节点左右子树的高度，相差不超过两倍
2. 特点
   1. 树根始终位黑色
   2. 叶子也始终为黑色
   3. 红节点的孩子比为黑色
   4. 从叶节点到根结点的黑高度相同
3. **理解** 红黑树与(2,4)树高度相关。因为红节点就可以认为是与父节点高度相同的兄弟关键码

### 插入算法

1. 先进行搜索，看能否找到该节点
2. 若没有，则将结点染红，并插入到相应的位置
3. 如果此时父节点也为红色，触发双红修正
   1. 局部的三四重构【并染色】【两个结点染色，并触发重构】
   2. 另一种情况则只染色（三个点染色），不重构

![2-3Tree to  RBTree](https://raw.githubusercontent.com/Gainlos/PicSet/main/img/2-3Tree%20to%20%20RBTree.jpg)

### 作业分析【与AVL相对比】

1. 插入的时候，红黑树的旋转次数少，所以块
2. 查找的时候，红黑树的高度更高，所以慢



## KD树

### 基本概念

1. 约定：**每个矩形区域的左边和底边开放（其上的点不属于该区域），右边和顶边封闭（其上的点属于该区域）**【所以在划线的时候要注意】



### 范围查询









## 拓扑排序

### 前缀知识

#### DFS

深度优先搜索，等效于树的先序遍历。DFS也能构造出原图的一棵支撑树。



#### BFS



### 适用对象

对有向无环图DAG进行排序。有向无环图必定可以进行拓扑排序。【存在性】



### 算法介绍

1. 顺序输出零入度的顶点。 利用邻接表来进行排序，先将0入度的点放入栈中，然后依次取出，并刷新邻接表中剩余点的入度。再将剩余的入度为0的点取出，以此类推。
2. 逆序输出零出度的顶点：利用DFS 。因为DFS能够很轻易的找到，出度为0的点，然后将其入栈即可。然后逆序输出所有的。





## 最短路径算法





### 优先级搜索

#### 介绍

==DFS和BFS==这两种算法的差异性体现在每一步迭代中对新顶点的选取策略不同，每一种选取策略都等效为，给所有顶点赋予不同的优先级，而且优先级随着算法的推进不断调整，在每一步迭代所选取的顶点，都是当时的优先级最高者，其实这个思想就是所谓的**优先级搜索**。





## Cuckoo哈希

### 基本概念

当想要进行hash的时候，如果已经有值了，就要将原有的值踢走。

### 基本操作

1. get 查找操作，较为简单，就是先对H1函数进行查找，若不是，再对H2函数进行hash查找
2. put 
   1. 若h1hash的位置空，插入
   2. 若h2hash的位置为空，插入
   3. 若不空，则将



==有点疑问，就是如何进行确定将谁踢出呢?==



### 可能发生死循环

 设置阈值，等循环达到阈值的时候，进行refresh







## 替罪羊树

### 概念介绍

1. α权重平衡
2. α高度平衡

### lab介绍

1. ​	用高度平衡判断是否需要重构，再利用权重，寻找Scapegoat
2. 插入
3. 删除

 ## LSM复习

### 特点及引入的必要性

1. 通过将增删改查以一定形成（在本次实验中是存在内存之中的memtable之中，利用跳表这一数据结构）存储在内存之中来避免直接对硬盘的读写，并在达到一定限度的时候将数据顺序的写入磁盘，从而更加便于数据的访问。

### 具体操作及缘由解释

1. PUT操作

   1. 先像内存Memtable中写入记录，如果超过界限，则写入SStable中。
   2. 如果SStable的数量超过了限制，就要触发compaction。
   3. 出发compaction的时候
      1. 当只有一层的时候，将所有的Level0层的进行合并
      2. 当文件数量超过level1层的限制的时候，将时间戳大的文件，向下合并。【时间戳大的是更新的数据，便于更新数据库中数据】
      3. 向下合并的时候，将上一层中选出的数据，与下一层中的有键值相交的数据所在SStable进行合并

2. GET操作

   先从内存中查找，若不存在，则在内存之中，逐一查找。查找的时候，先从BloomFilter查找，然后再利用二分查找，在索引区中找到offset。

3. DEL操作 

   SStable由于是只读的，不能进行修改。所以要进行另一种操作

   1. 首先查找键，若没找到，则不用阐述
   2. 若找到，则在SStable中插入一条Delete记录。
   3. 在合并的时候，不需要进行特殊的处理，直到最后一层。【因为如果中间某一层提前删除掉的话，会导致后面的层数没法进行及时的更新】

4. RESET操作

5. ==scan==

   有两种实现方式

   1.  扫描MemTable和所有的SStable中的数据
   2.  通过多个指针进行堆排序



## 归并排序

### 作业分析

1. 多路归并
2. 二路归并











## KMP算法

### 关键在于next数组的生成。

如何构建next数组

1. 首先令next[0] = -1
2. 然后推过递推来得到后面的next数组。已知next[j] = t,然后依次推断next[j+1]【这一步有点像自我匹配】
3. 



## Scapegoat

### 插入重构

 要注意根节点的深度为0







## 过定点最短路

### 思路

1. 利用dijkstra计算起点与n个必经点组成集合中 两两最短的距离和路径
1. 对n个中间结点进行全排列，有n!中间节点序列





## 多线程编程基础

### 互斥锁

​	mutex类来提供lock和unlock两种方法，来确保同一时间，只有一个线程可以执行。



## PageRank





## Kruskal





